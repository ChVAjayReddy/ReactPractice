import React, { useState, useCallback, memo } from "react";
// Child component wrapped in React.memo for optimization
 const ProductItem = memo(({ product, onDelete }) => { console.log(Rendering product item: ${product.name});
 
 return ( <div style={{ padding: '10px', border: '1px solid #ccc', marginBottom: '5px' }}> <span>{product.name}</span> {/* Pass the memoized onDelete handler */} <button onClick={() => onDelete(product.id)} style={{ marginLeft: '10px' }}> Delete </button> </div> ); }); function ProductListManager() { const [products, setProducts] = useState([ { id: 1, name: 'Laptop' }, { id: 2, name: 'Smartphone' }, { id: 3, name: 'Headphones' }, ]); const [filterTerm, setFilterTerm] = useState(''); // Memoize the delete function const handleDelete = useCallback((productId) => { setProducts(prevProducts => prevProducts.filter(product => product.id !== productId)); }, []); // Empty dependency array ensures the same function instance is used across renders const filteredProducts = products.filter(product => product.name.toLowerCase().includes(filterTerm.toLowerCase()) ); return ( <div> <input type="text" placeholder="Filter products..." value={filterTerm} onChange={(e) => setFilterTerm(e.target.value)} /> <h3>Product List</h3> {/* Changing the filterTerm state will cause ParentComponent to re-render, but ProductItem components will not re-render unnecessarily because the handleDelete function reference remains stable. */} {filteredProducts.map(product => ( <ProductItem key={product.id} product={product} onDelete={handleDelete} /> ))} </div> ); } export default ProductListManager;
